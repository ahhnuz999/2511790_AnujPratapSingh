# -*- coding: utf-8 -*-
"""worksheet1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hM9A6EPkgD7PRMgFOKMIHwzP66Yl3Vaz
"""

# Problem - 1 : Array Creation :
import numpy as np

# 1. Initialize an empty array with size 2x2
arr_empty = np.empty((2, 2))
print("\n", arr_empty)

# 2. Initialize an all-one array with size 4x2
arr_ones = np.ones((4, 2))
print("\n", arr_ones)

# 3. Return a new array of given shape and type, filled with fill value (np.full)
arr_full = np.full((3, 3), fill_value=7)   # Example: 3x3 filled with 7
print("\n", arr_full)

# 4. Return a zeros array with same shape and type as a given array (np.zeros_like)
given_array = np.array([[5, 6], [7, 8]])
arr_zeros_like = np.zeros_like(given_array)
print("\n", arr_zeros_like)

# 5. Return a ones array with same shape and type as a given array (np.ones_like)
arr_ones_like = np.ones_like(given_array)
print("\n", arr_ones_like)

# 6. Convert a list to numpy array
new_list = [1, 2, 3, 4]
arr_from_list = np.array(new_list)
print("\n", arr_from_list)

# Problem - 2 : Array Manipulation
import numpy as np

# 1. Create an array with values ranging from 10 to 49. {Hint:np.arrange()}.

a = np.arange(10,50)
print("\n",a)

# 2. Create a 3X3 matrix with values ranging from 0 to 8.
# {Hint:look for np.reshape()}

b = np.arange(9).reshape(3,3)
print("\n",b)

# 3. Create a 3X3 identity matrix.{Hint:np.eye()}

c = np.eye(3,3)
print("\n",c)

# 4. Create a random array of size 30 and find the mean of the array.
# {Hint:check for np.random.random() and array.mean() function}

d = np.random.random(30)
print("\nArray:",d)
print("\nArray:",d.mean())

# 5. Create a 10X10 array with random values and find the minimum and maximum values.

e = np.random.random((10, 10))
print("\nMin:", e.min())
print("\nMax:", e.max())

# 6. Create a zero array of size 10 and replace 5th element with 1.

f = np.zeros(10)
f[4] = 1
print("\n",f)

# 7. Reverse an array arr = [1,2,0,0,4,0].

arr = np.array([1, 2, 0, 0, 4, 0])
rev = np.flip(arr)
print("\n",rev)

# 8. Create a 2d array with 1 on border and 0 inside.

g = np.ones((5, 5))
g[1:-1, 1:-1] = 0
print("\n",g)

# 9. Create a 8X8 matrix and fill it with a checkerboard pattern.

h = np.zeros((8, 8))
h[1::2, ::2] = 1
h[::2, 1::2] = 1
print("\n",h)

# Problem - 3 : Array Operations:
import numpy as np

x = np.array([[1,2],[3,5]])
y = np.array([[5,6],[7,8]])
v = np.array([9,10])
w = np.array([11,12])

# 1. Add the two array.

add_xy = x+y
print("\n",add_xy)

# 2. Subtract the two array.

sub_xy = x - y
print("x - y =\n", sub_xy)

# 3. Multiply the array with any integers of your choice.

mul_x3 = x * 3  # multiply by 3
print("x * 3 =\n", mul_x3)

# 4. Find the square of each element of the array.

square_x = x ** 2
print("x squared =\n", square_x)

# 5. Find the dot product between: v(and)w ; x(and)v ; x(and)y.

dot_vw = np.dot(v, w)
print("v . w =", dot_vw)

dot_xv = np.dot(x, v)
print("x . v =", dot_xv)

dot_xy = np.dot(x, y)
print("x . y =\n", dot_xy)



# 6. Concatenate x(and)y along row and Concatenate v(and)w along column.
# {Hint:try np.concatenate() or np.vstack() functions.

concat_xy_row = np.vstack((x, y))
print("x and y concatenated along row:\n", concat_xy_row)

# 7. Concatenate x(and)v; if you get an error, observe and explain why did you get the error?

xwithv = np.concatenate((x,v), axis=0)

#Explaination: NUmpy cannot concatenate arrays of different dimensions along default axis(0)

# Problem 4: Matrix Operations:
import numpy as np

A = np.array([[3,4],[7,8]])
B = np.array([[5,3],[2,1]])

# 1.

I = np.eye(2, dtype=int)
A_inv = np.linalg.inv(A)
AdotAinv = np.dot(A,A_inv)
AdotAinv_int = np.round(AdotAinv).astype(int)
print(AdotAinv_int)

if np.array_equal(AdotAinv_int, I):
    print("\nTrue")
else:
    print("\nFalse")

# 2.

AB = np.dot(A,B)
BA = np.dot(B,A)
print("\nAB=\n",AB)
print("\nBA=\n",BA)

if np.array_equal(AB, BA):
    print("\nBoth are equal")
else:
    print("\nNot equal")

# 3.

AB_T = np.dot(A, B).T
BT_AT = np.dot(B.T, A.T)
print("(AB)^T =\n", AB_T)
print("B^T A^T =\n", BT_AT)


if np.array_equal(AB_T, BT_AT):
    print("Property Verified: (AB)^T = B^T A^T")
else:
    print("Property Not Verified")

# 4.

A_eq = np.array([[2, -3, 1],[1, -1, 2],[3, 1, -1]])
B_eq = np.array([-1, -3, 9])

X = np.dot(np.linalg.inv(A_eq), B_eq)
print("\nSolution [x, y, z] =", X)

#Experiment

import time
import numpy as np

list1 = list(range(1_000_000))
list2 = list(range(1_000_000))

start_time = time.time()

list_result = [list1[i] + list2[i] for i in range(1_000_000)]

end_time = time.time()

print("Time taken for element-wise addition using Python lists:",
      end_time - start_time, "seconds")

#using numpy
arr1 = np.array(list1)
arr2 = np.array(list2)

start_time = time.time()

arr_result = arr1 + arr2

end_time = time.time()

print("Time taken using NumPy arrays:",
      end_time - start_time, "seconds")

#element wise multiplication

import time
import numpy as np

list1 = list(range(1_000_000))
list2 = list(range(1_000_000))

start_time = time.time()

list_result = [list1[i] * list2[i] for i in range(1_000_000)]

end_time = time.time()

print("Time taken for element-wise addition using Python lists:",
      end_time - start_time, "seconds")

#using numpy
arr1 = np.array(list1)
arr2 = np.array(list2)

start_time = time.time()

arr_result = arr1 * arr2

end_time = time.time()

print("Time taken using NumPy arrays:",
      end_time - start_time, "seconds")

import time
import numpy as np

list1 = list(range(1_000_000))
list2 = list(range(1_000_000))

start_time = time.time()

dot_product_list = 0
for i in range(1_000_000):
    dot_product_list += list1[i] * list2[i]

end_time = time.time()

print("Dot product using Python lists:", dot_product_list)
print("Time taken (Python lists):", end_time - start_time, "seconds")

#using numpy
arr1 = np.array(list1)
arr2 = np.array(list2)

start_time = time.time()
dot_product_numpy = np.dot(arr1, arr2)

end_time = time.time()

print("\nDot product using NumPy:", dot_product_numpy)
print("Time taken (NumPy):", end_time - start_time, "seconds")

import time
import numpy as np
import random

size = 1000
matrix1 = [[random.randint(0, 9) for i in range(size)] for i in range(size)]
matrix2 = [[random.randint(0, 9) for i in range(size)] for i in range(size)]

start_time = time.time()

result_list = [[0]*size for i in range(size)]

for i in range(size):
    for j in range(size):
        sum_val = 0
        for k in range(size):
            sum_val += matrix1[i][k] * matrix2[k][j]
        result_list[i][j] = sum_val

end_time = time.time()
print("Time taken for matrix multiplication using Python lists:", end_time - start_time, "seconds")

#using numpy
arr1 = np.array(matrix1)
arr2 = np.array(matrix2)

start_time = time.time()

result_numpy = np.dot(arr1, arr2)

end_time = time.time()
print("Time taken for matrix multiplication using NumPy arrays:", end_time - start_time, "seconds")



